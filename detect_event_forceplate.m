function [frame_contact,frame_off,frame_contact2,frame_off2] = detect_event_forceplate(acq)
analogs = btkGetAnalogs(acq); % will extract the values of all the analogs entry given by qualisys
ratio = btkGetAnalogSampleNumberPerFrame(acq); %will compute the ratio between the sampling frequency of the analogs entry and of the cameras. The data is not sampled doxn in this case as both the force plates and the optogait are sampled at 2000Hz
labels = fieldnames(analogs);
grf = btkGetGroundReactionWrenches(acq); %will extract the values of wrenches. May generat a warning message because of the frame used to determine the position of the plate in space, but it is not a problem as moments are not computed
grf1=grf(1).F(:,[3]); %creates a vector with only the Z components (3rd col) of the force for the 1st plate
grf2=grf(2).F(:,[3]); %same for the 2nd plate
plot(grf1); %only a test to assure the correct data have been extracted
hold on;
plot(grf2);
hold off;
%event detection for the force plate---------------------------------------
%the choice of the threshold for foot contact and foot off is based on :  Tirosh O, Sparrow WAT. Identifying heel contact and toe-off using forceplate thresholds with a range of digital-filter cutoff frequencies. JAppl Biomech 2003;19:178–84
num_samples=size(grf1,1); %get the number of samples of the measurement
wait_for_contact=true; %variables that will change of status depending if a contact or a off should be expected
wait_for_off=false;    %same
i=1;    %used for incrementation of the frame
j=1;    %used for the incrementation of the array storing the frame of events
k=1;    %same
while i <num_samples;   %loop to go through all the data
    if wait_for_contact==true;  %at the starts it is considered that a foot contact will occur
        if grf1(i,1)>5; %the threshold for foot contact is 5N
            frame_contact(j,1)=i;   %if the treshold is passed, the frame were it occured is stored
            j=j+1;  %increment to store the next frame
            wait_for_contact=false; %invert the state and stop looking for contact
            wait_for_off=true;  %invert the state and will start looking for foot off
            i=i+20;  %artificial increment to make sure the peaks generated by the remaning noise are not falsely detected as the next event
        end
        i=i+1;% going to the next sample
    end
    if wait_for_off==true;  %same comments
        if grf1(i,1)<10;
            frame_off(k,1)=i;
            k=k+1;
            wait_for_contact=true;
            wait_for_off=false;
            i=i+400; %this increment is in fact more useful for the foot off
        end;
        i=i+1;
    end;
end;

num_samples=size(grf1,1); %get the number of samples of the measurement
wait_for_contact=true; %variables that will change of status depending if a contact or a off should be expected
wait_for_off=false;    %same
i=1;    %used for incrementation of the frame
j=1;    %used for the incrementation of the array storing the frame of events
k=1;    %same
while i <num_samples;   %loop to go through all the data
    if wait_for_contact==true;  %at the starts it is considered that a foot contact will occur
        if grf2(i,1)>5; %the threshold for foot contact is 5N
            frame_contact2(j,1)=i;   %if the treshold is passed, the frame were it occured is stored
            j=j+1;  %increment to store the next frame
            wait_for_contact=false; %invert the state and stop looking for contact
            wait_for_off=true;  %invert the state and will start looking for foot off
            i=i+20;  %artificial increment to make sure the peaks generated by the remaning noise are not falsely detected as the next event
        end
        i=i+1;% going to the next sample
    end
    if wait_for_off==true;  %same comments
        if grf2(i,1)<10;
            frame_off2(k,1)=i;
            k=k+1;
            wait_for_contact=true;
            wait_for_off=false;
            i=i+400; %this increment is in fact more useful for the foot off
        end;
        i=i+1;
    end;
end;
end